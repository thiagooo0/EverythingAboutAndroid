#### 0001给定数组找两数之和
**哈希表**
#### 0021合并两升序数组
**递归**

#### 0070青蛙爬楼梯
**动态规划**

#### 0101二叉树是否镜像对称
**递归**

判空，然后递归(left.left,right.right),(left.right,right.left)

#### 0104二叉树的最大深度
**遍历**
**深度优先**

#### 0155设计有push,pop,top操作的，能在常数时间内检索到最小元素的栈
**辅助栈**

对于同步的情况，辅助栈每一位的数代表了从头到对应位置之间的最小值。每次插入值的时候，都和栈顶比较，如果自己小就把自己存进去，
如果栈顶小，就存栈顶。pop的时候，两个栈一起pop。

对于异步栈，则是同步的改进版，只是存进小于等于栈顶数的数。pop的时候只有两个栈栈顶数相同的时候，辅助栈才pop。这样可以有效节省空间。当然第一次的时候，怎么都要加的。

#### 0160寻找两链表第一个公节点
**链表拼接**
两个指针，分别从两个链表表头开始，到了结尾就到另外一条链表继续遍历。
这样操作可以磨平两个链表之间的长度差距。
一个要点是到链表结尾的判断是指针为空，而不是指针的next为空（这样会导致在没有公共节点的情况下循环结束不了）。

**哈希表**

#### 0169某数出现次数超过数组长度的一半，找出此数
*摩尔投票*
抵消法，由于目标数超过数组长度的一半，所以就算数组中不同的元素都两两抵消，到最后剩下来的肯定是目标数

**哈希表**
#### 0191输出某整数的二进制数中1的个数
**原码，反码，补码的知识点**
**位运算**
1. 无符号右移动，直到0
2. 这里用到了一个小技巧，对于任何数n，将其与n-1相与（&），都会把最后一个1去掉。
因为n-1的时候，最后一个1会被置成0，然后后面的0都变成1。和n相与后，都会被消掉了。
****
#### 0206 翻转链表
**递归**

#### 0235 找搜索二叉树公共祖先
**递归**
**判断分叉点

#### 0236 找二叉树公共祖先
**递归**
**判断分叉点

#### 0240升序二维数组中寻找目标值
**逐行逐列排除**
**暴力二分查找**
#### 1542 寻找超赞字符串
**状态压缩** + **异或运算** + **前缀和**
#####
#####
#####
#####
#####
#####